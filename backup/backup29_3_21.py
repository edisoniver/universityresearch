#!/usr/bin/env python
# pylint: disable=C0116
# This program is dedicated to the public domain under the CC0 license.

"""
First, a few callback functions are defined. Then, those functions are passed to
the Dispatcher and registered at their respective places.
Then, the bot is started and runs until we press Ctrl-C on the command line.

Usage:
Example of a bot-user conversation using ConversationHandler.
Send /start to initiate the conversation.
Press Ctrl-C on the command line or send a signal to the process to stop the
bot.
"""

import logging
import requests
import json



from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Updater,
    CommandHandler,
    MessageHandler,
    Filters,
    ConversationHandler,
    CallbackContext,
    CallbackQueryHandler
)

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)

logger = logging.getLogger(__name__)
#PENALTY_FREQUENCY
PROMPT, MAX_TOKEN, TEMPERATURE, OUTPUT  = range(4)

def help(update, context):
    "Send a message when the command /tutorial is issued."
    user = update.message.from_user
    update.message.reply_text("---TUTORIAL---")
    update.message.reply_text("\nYou will need to learn how to properly generated your own prompts.")
    update.message.reply_text("-TUTORIAL FILE-. PLEASE READ \n http://203.57.50.107/outputs/tutorial.txt")
    update.message.reply_text("-ALL OUTPUTS GENERATED BY PEOPLE- \nhttp://203.57.50.107/outputs/outputs.txt")
    update.message.reply_text("/start to start the bot. \n\n/cancel to restart the bot at anytime.")

def start(update, context):
    "Send a message when the command /start is issued."
    user = update.message.from_user
    update.message.reply_text("---Currently in development---")
    update.message.reply_text("To be used for research purposes only\n\nPlease go to first -> /help for help & more information\n")
    update.message.reply_text("---Please input your prompt---")
    return PROMPT

def prompt(update: Update, _: CallbackContext) -> int:
    user = update.message.from_user
    logger.info("Bio of %s: %s", user.first_name, update.message.text)
    update.message.reply_text('---Max Token---: [50-350]\nPlease select a value:\n\nLength of the output. The larger it is, the more expensive.')
    global prompt_value
    prompt_value = ('%s') % update.message.text



    print("PROMPT", prompt_value)
    return MAX_TOKEN

def max_token(update: Update, _: CallbackContext) -> int:
    user = update.message.from_user
    logger.info("MAX TOKEN: %d", float(update.message.text))
    update.message.reply_text('---Creativity Value---\n\n0 is definite and factual\n\n1 is creative and different \nPlease select a value: from [0 - 1] \nCommon values: 0.2 - 0.4 - 0.7 - 0.9')
    global max_token_value
    max_token_value = float(update.message.text)
    print("MAXTOKEN ", max_token_value)
    return TEMPERATURE

def temperature(update: Update, context: CallbackContext) -> int:
    user = update.message.from_user
    chat_id = update.effective_chat.id
    Keyboard = [
        [
        InlineKeyboardButton("ada", callback_data='1'),
        InlineKeyboardButton("babbage", callback_data='2'),
        InlineKeyboardButton("curie", callback_data='3'),
        InlineKeyboardButton("davinci", callback_data='4'),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(Keyboard)
    logger.info("TEMPERATURE: %d", float(update.message.text))
    update.message.reply_text('---Compiling data---\nPlease select an engine.\n---ENGINE---', reply_markup=reply_markup)
    global temperature_value
    temperature_value = float(update.message.text)
    print("temp_value", temperature_value)
    return OUTPUT
    #return PENALTY_FREQUENCY
# def penalty_frequency(update: Update, _: CallbackContext) -> int:
#     user = update.message.from_user
#     logger.info("PENALTY FREQUENCY: %d", float(update.message.text))
#     update.message.reply_text('---Compiling data---\nPlease select an engine.\nENGINE: ada | babbage | curie | davinci')
#     global penalty_frequency_value
#     penalty_frequency_value = float(update.message.text)
#     print("PENALTHY FREQUENCY ->", penalty_frequency_value)
#     return OUTPUT

def output(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    chat_id = update.effective_chat.id
    choice = query.data
    if choice == '1': #ada
        enginebtn = 'ada'
        query.edit_message_text(text="Engine: ada")
        #context.bot.send_message(chat_id=chat_id, text='ada selected.')
    if choice == '2': #ada
        enginebtn = 'babbage'
        query.edit_message_text(text="Engine: babbage")
    if choice == '3': #ada
        enginebtn = 'curie'
        query.edit_message_text(text="Engine: curie")   #user = update.message.from_user
    if choice == '4': #ada
        enginebtn = 'davinci'
        query.edit_message_text(text="Engine: davinci")
    logger.info("ENGINE: %s", str(enginebtn))
    global engine_value
    engine_value = enginebtn
    #engine = str(update.message.from_user.text)
    #engine_value = engine.replace(" ", "")
    #engine_value = str.lower(engine_value)
    print("ENGINE VALUE --> ", engine_value)
    global url
    url = 'https://api.openai.com/v1/engines/%s/completions' % engine_value
    context.bot.send_message(chat_id=chat_id, text=("Prompt: {0}".format(prompt_value)))
    call() #call the OPENAI API HERE 
    for x in textoutput3:
        context.bot.send_message(chat_id=chat_id, text=(x))
    context.bot.send_message(chat_id=chat_id, text="\n/cancel to restart bot.")
    return ConversationHandler.END

def cancel(update: Update, _: CallbackContext) -> int:
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    update.message.reply_text(
        '/start to input a prompt & start the bot.', reply_markup=ReplyKeyboardRemove()
    )

    return ConversationHandler.END


def call():
    headers = {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer sk-0v2la3a279fRolIzQR4l5t71OvD3YAmQpwLWiomU',
    }   


    promptoutput = prompt_value
    input_data = ' "prompt": "{0}", "max_tokens": {1}, "temperature": {2} '.format(prompt_value, int(max_token_value), float(temperature_value))
    global data
    data = "{%s}" % input_data
    print(input_data, data)

    
    response = requests.post(url, headers=headers, data=data) 
    print(url)
    print(response)
    global textoutput3
    output = response.json()
    global textoutput
    textoutput1 = output.get("choices")
    global textoutput2
    textoutput2 = str(textoutput1)
    textoutput3 = textoutput2.rstrip()
    
    textoutput3 = textoutput2.split("\\n")
    textoutput3 = list(filter(None, textoutput3))
    remove = "[{'text':"
    remove2 = "'index': 0, 'logprobs': None, 'finish_reason': 'length'}]"
    textoutput3[0] = textoutput3[0].replace(remove, '')
    textoutput3[-1] = textoutput3[-1].replace(remove2, '')


    #resultant = textoutput.split(':')
    #global resultant2
    #resultant2 = str(resultant[1])
    #global resultant3
    #resultant3 = resultant2.strip("'index")
    f = open("/var/www/personal/outputs/outputs.txt", "a+")
    data_collected = '\n---SETUP---\nPROMPT: {0}\nTOKENS: {1}\nFREQUENCY: {2}\nOUTPUT: {3}\n---END---\n'.format(prompt_value, int(max_token_value), float(temperature_value), textoutput3)
    f.write(data_collected)
    f.close()

    return textoutput3
    # Note to self: Create a txt and append prompts and outputs.
    # Clean up json and have a cleaner output and better user experience.

def main() -> None:
    # Create the Updater and pass it your bot's token.
    updater = Updater("1637606604:AAENJDUte9UsHDKVcv4kDjrFuUxb1zKdD24")

    # Get the dispatcher to register handlers
    dispatcher = updater.dispatcher

    # Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            PROMPT: [MessageHandler(Filters.text & ~Filters.command, prompt)],
            MAX_TOKEN: [MessageHandler(Filters.text & ~Filters.command, max_token)],
            TEMPERATURE: [MessageHandler(Filters.text & ~Filters.command, temperature)],
            #PENALTY_FREQUENCY: [MessageHandler(Filters.text & ~Filters.command, penalty_frequency)],
            OUTPUT: [MessageHandler(Filters.text & ~Filters.command, output)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )

    dispatcher.add_handler(conv_handler)
    dispatcher.add_handler(CommandHandler("help", help))
    dispatcher.add_handler(CallbackQueryHandler(output))

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()


if __name__ == '__main__':
    main()
